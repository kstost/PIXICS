<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport"
        content="width=device-width, height=device-height, initial-scale=1.0001, minimum-scale=1.0001, maximum-scale=1.0001, user-scalable=no" />
    <script
        src="https://cdn.jsdelivr.net/gh/flyover/box2d.ts@48e167c59afbfd9262c6051529692cd394d7938e/dist/box2d.umd.js"></script>
    <script src="./testcode.js"></script>
    <style>
        body {
            background-color: aaa;
        }
    </style>
</head>

<body>
    <canvas id="stage"></canvas>
    <script>
        javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = '//mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })()
        let WIDTH = 500;
        let HEIGHT = 500;
        let canvas, context;
        let m_world;
        let timeStep = 1000 / 60;
        window.addEventListener('load', function () {
            canvas = document.getElementById('stage');
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            context = canvas.getContext('2d');
            m_world = new b2.World(new b2.Vec2(0, Config.gravity));
            init(m_world);
            tick();
        });
        let Config = {
            timeScale: 1.3 / 1000,
            gravity: -9.8,
            positionIterations: 3,
            velocityIterations: 8,
            angularVelocity: 0.2,
            boardWidth: 40,
            boardHeight: 1,
            circleRaius: 3,
            circleMargin: 12,
            boxSize: 0.8,
        }
        function drawPoly(ctx, vertices, vertexCount) {
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (var i = 1; i < vertexCount; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        }
        function drawCircle(ctx, radius, x, y) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        function render(ctx, timeStep) {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            ctx.save();
            ctx.translate(WIDTH / 2, HEIGHT / 2); // Translate to the center
            ctx.scale(10, -10); // Zoom in and flip y axis
            ctx.lineWidth = 0.1;
            for (var b = m_world.m_bodyList; b; b = b.m_next) {
                var xf = b.m_xf;
                ctx.save();
                ctx.translate(xf.p.x, xf.p.y);
                ctx.rotate(xf.q.GetAngle());
                for (var f = b.m_fixtureList; f; f = f.m_next) {
                    var shape = f.GetShape();
                    if (shape.m_vertices) {
                        drawPoly(context, shape.m_vertices, shape.m_count);
                    } else if (shape.m_p) {
                        drawCircle(context, shape.m_radius, shape.m_p.x, shape.m_p.y);
                    }
                }
                ctx.restore();
            }
            ctx.restore();
        }
        function tick() {
            update(timeStep);
            render(context, timeStep);
            requestAnimationFrame(tick);
        }
        function update(timeStep) {
            timeStep *= Config.timeScale;
            m_world.Step(timeStep, Config.velocityIterations, Config.positionIterations);
        }
        function delay(t) {
            return new Promise(r => setTimeout(r, t))
        }
    </script>
</body>

</html>